**Детализированный План Реализации и Передачи Проекта (на основе PRD v1.3)**

### **Фаза 1: Подготовка и Базовая Настройка (Оценка: 3-5 дней)**

**Цель:** Создать основу проекта, настроить окружение и обеспечить базовый доступ к данным.
1. **Создание Репозитория Проекта:**
    - Инициализировать Git-репозиторий для кода Node.js.
    - Настроить базовую структуру папок (src, scripts, config, tests, docs).
    - Создать `.gitignore` (включить `.env`, `node_modules`, `dist`, и т.д.).
2. **Настройка Среды Разработки:**
    - Следовать "Руководству по Настройке Среды Разработки" из `prd_assumptions_setup_guide`.
    - Установить Node.js, npm, Docker, Pandoc.
    - Создать базовый `package.json`.
    - Установить основные зависимости: `dotenv`, фреймворк для логирования (`pino`/`winston`), базовые утилиты.
	
3. **Настройка Docker (Базовая):**
    - Создать начальный `Dockerfile` для Node.js приложения.
    - (Опционально) Создать `docker-compose.yml` для локального запуска PostgreSQL и Qdrant (для разработки/тестирования).
	
4. **Настройка Доступа к Git (Источник MD):**
    - Реализовать скрипт/модуль на Node.js (используя `simple-git` или `child_process`) для:
        - Клонирования/обновления репозитория с MD-файлами по URL из `.env`.
        - Обработки аутентификации (SSH-ключ/токен из `.env`).
        - Определения `module_id` по структуре папок.
    - Настроить переменные окружения (`GIT_REPO_URL`, `GIT_SSH_KEY_PATH`/`GIT_ACCESS_TOKEN`).
        
5. **Настройка Подключения к Базам Данных:**
    - Установить клиенты: `@supabase/supabase-js`, `@qdrant/js-client`.
    - Реализовать модули конфигурации для подключения к Supabase/PostgreSQL и Qdrant, используя данные из `.env`.
    - Написать простые тесты подключения к БД (локально или на Coolify).
    - Настроить переменные окружения (`SUPABASE_URL`, `SUPABASE_ANON_KEY`, `QDRANT_URL`, `QDRANT_API_KEY` и т.д.).
        
6. **Проверка Предположения 6 (Coolify):**
    
    - Развернуть "hello-world" Node.js, PostgreSQL, Qdrant на Coolify.

    Хорошо, давайте детально разберем, как выполнить пункт 1.6 для проверки развертывания на Coolify, используя созданный `hello-world` пример.

    **Предварительные шаги:**

    1.  **Git Репозиторий:** Убедитесь, что папка `hello-world` со всеми файлами (`index.js`, `package.json`, `Dockerfile`, `docker-compose.yml`) добавлена, закоммичена и отправлена (pushed) в Git-репозиторий (например, на GitHub, GitLab, Bitbucket), к которому у вашего Coolify есть доступ.
    2.  **Доступ Coolify: как настроить подключение к Git-репозиторию?**
        - Войдите в веб‑интерфейс Coolify → раздел «Settings» → «Integrations» → «Git Provider».
        - Для SSH‑доступа:
            1. Сгенерируйте SSH‑ключ: ssh-keygen -t ed25519 -C "coolify".
            2. Добавьте публичный ключ (id_ed25519.pub) в раздел SSH‑keys вашего репозитория на GitHub/GitLab.
            3. В настройках Coolify загрузите приватный ключ (id_ed25519).
        - Для доступа через GitHub App:
            1. Нажмите «Connect with GitHub» и авторизуйте Coolify как GitHub App.
            2. Выберите нужные репозитории и подтвердите доступ.
        - Убедитесь, что статус подключения отображается как «Connected», а ваш репозиторий доступен для деплоя.

    **Шаги в интерфейсе Coolify:**

    1.  **Вход и Создание Проекта:**
        *   Войдите в свой Coolify.
        *   Перейдите в раздел "Projects".
        *   Нажмите "Create New Project".
        *   Дайте проекту имя, например, `SCPL Test Deployment`.

    2.  **Добавление Источника (Source):**
        *   Внутри нового проекта перейдите на вкладку "Sources".
        *   Нажмите "Add Source".
        *   Выберите ваш Git-провайдер (GitHub, GitLab и т.д.).
        *   Выберите репозиторий, содержащий ваш проект (включая папку `hello-world`).

    3.  **Развертывание PostgreSQL:**
        *   Перейдите на вкладку "Resources" вашего проекта.
        *   Нажмите "Add Resource".
        *   Выберите тип ресурса: "PostgreSQL".
        *   Задайте имя сервиса, например, `test-postgres`.
        *   Выберите желаемую версию PostgreSQL (например, 15).
        *   Coolify обычно автоматически генерирует пользователя, пароль и имя базы данных. Вы можете найти их на вкладке "Environment Variables" созданного ресурса PostgreSQL *после* первого деплоя, или задать свои переменные `POSTGRES_USER`, `POSTGRES_PASSWORD`, `POSTGRES_DB` перед деплоем.
        *   Нажмите "Deploy". Дождитесь статуса `Running`.

    4.  **Развертывание Qdrant:**
        *   Снова нажмите "Add Resource".
        *   Выберите тип ресурса: "Qdrant" (если доступно) или "Docker Image".
            *   **Если выбрали "Qdrant":**
                *   Задайте имя, например, `test-qdrant`.
                *   Убедитесь, что порт `6333` указан.
                *   Если используете API-ключ, добавьте переменную окружения `QDRANT_API_KEY` с вашим ключом.
            *   **Если выбрали "Docker Image":**
                *   Задайте имя, например, `test-qdrant`.
                *   В поле "Image" укажите `qdrant/qdrant:v1.7.4`.
                *   В настройках сети (Networking) укажите порт `6333`.
                *   Если используете API-ключ, добавьте переменную окружения `QDRANT_API_KEY` с вашим ключом.
        *   Нажмите "Deploy". Дождитесь статуса `Running`.

    5.  **Развертывание Node.js Приложения (`hello-world`):**
        *   Снова нажмите "Add Resource".
        *   Выберите тип ресурса: "Application".
        *   **General:**
            *   Задайте имя, например, `test-hello-world-app`.
            *   Выберите Git Source (ваш репозиторий) и нужную ветку.
        *   **Build:**
            *   Выберите "Dockerfile" как Build Pack.
            *   **Dockerfile Location:** `/hello-world/Dockerfile` (Путь от корня репозитория).
            *   **Base Directory:** `/hello-world/` (Указывает, что команды типа `COPY` в Dockerfile должны работать относительно этой папки).
        *   **Network:**
            *   **Ports:** Укажите `3000` (порт, который слушает ваше Node.js приложение). Coolify автоматически назначит внешний порт.
        *   **(Опционально, для демонстрации связей)**: На вкладке "Environment Variables" можно добавить переменные для подключения к другим сервисам, используя внутренние DNS-имена Coolify (они обычно совпадают с именами сервисов):
            *   `POSTGRES_URL=postgresql://<user>:<password>@test-postgres:5432/<database>` (замените `<user>`, `<password>`, `<database>` на значения из шага 3).
            *   `QDRANT_URL=http://test-qdrant:6333`
            *   (Хотя само приложение `hello-world` их не использует, это показывает, как вы будете настраивать основное приложение).
        *   Нажмите "Deploy". Дождитесь статуса `Running`.

    6.  **Проверка и Валидация:**
        *   Убедитесь, что все три ресурса (`test-postgres`, `test-qdrant`, `test-hello-world-app`) имеют статус `Running`.
        *   Проверьте логи каждого ресурса на вкладке "Logs" на наличие ошибок запуска или работы.

    7.  **Тестирование Сетевого Взаимодействия:**
        *   **Node.js App:**
            *   На странице ресурса `test-hello-world-app` найдите сгенерированный FQDN (Public URL).
            *   Откройте в браузере или используйте `curl`: `curl http://<ваш-fqdn>/health`. Вы должны увидеть ответ `OK`.
        *   **PostgreSQL:**
            *   На странице ресурса `test-postgres` найдите данные для подключения (хост, порт, пользователь, пароль, база данных). Они могут быть доступны как переменные окружения или на отдельной вкладке.
            *   Используйте любой SQL-клиент (psql, DBeaver, pgAdmin) для подключения к базе данных с этими учетными данными. Успешное подключение подтверждает доступность сервиса.
        *   **Qdrant:**
            *   Найдите URL для Qdrant (вероятно, он будет доступен только внутри сети Coolify, но если вы пробросили порт наружу или используете Coolify Proxy, у вас может быть и внешний URL. Для проверки взаимодействия из Node.js приложения достаточно внутреннего).
            *   Если у вас есть доступ к окружению, откуда виден Qdrant (например, через SSH в контейнер Node.js или используя прокси), выполните: `curl http://test-qdrant:6333/` или `curl http://test-qdrant:6333/collections`. Должен вернуться ответ от Qdrant API (например, информация о сервере или пустой список коллекций).

    Если все эти шаги прошли успешно, вы подтвердили, что ваш стек (Node.js + PostgreSQL + Qdrant) может быть развернут и базово взаимодействовать в среде Coolify.

**Результат Фазы 1:**
- Настроенный репозиторий проекта.
- Рабочая локальная среда разработки.
- Базовый Dockerfile.
- Скрипт для получения исходных MD-файлов из Git.
- Проверенное подключение к Supabase и Qdrant.
- Подтвержденная возможность развертывания стека на Coolify.

### **Фаза 2: Предобработка Markdown (Оценка: 5-7 дней)**

**Цель:** Реализовать шаги предобработки Markdown файлов: конвертация DOCX (инструкции), замена изображений на Mermaid, разделение по заголовкам.

1. **Руководство по Конвертации DOCX:**
    - Документировать в `README.md` процесс ручной конвертации `.docx` в `.md` с помощью `pandoc` (команда, структура папок `media`).
    - **Проверка Предположения 1 (Pandoc):** Выполнить тесты конвертации на реальных примерах `.docx`.
        
2. **Реализация Замены Изображений на Mermaid:**
    - Установить зависимости для парсинга MD (`remark`, `unist-util-visit`).
    - Реализовать функцию парсинга MD для поиска тегов изображений (`![]()`, `<img>`).
        
    - Реализовать интеграцию с OpenRouter API:
        - Установить HTTP-клиент (`axios`/`node-fetch`).
        - Настроить вызов API с промптом (из конфигурации), контекстом изображения (alt, path, окружение).
        - Обработать ответы и ошибки API.
            
    - Реализовать логику замены тега изображения на блок Mermaid.
    - **Проверка Предположения 2 (LLM для Mermaid):** Протестировать генерацию Mermaid на разных примерах, итеративно улучшить промпт.
    - **Проверка Предположения 7 (API Limits - OpenRouter):** Мониторить лимиты во время тестов.
        
3. **Реализация Разделения по Заголовкам:**
    - Используя `remark`, реализовать логику разделения MD-документа на чанки на основе уровня заголовка (уровень настраивается в `.env`).
    - Для каждого чанка сохранять: текст, `source_file_name`, `module_id`, иерархию заголовков, порядковый номер.
    - **Проверка Предположения 5 (Стратегия Сплиттинга):** Протестировать на реальных документах, оценить качество чанков.
        
4. **Создание Скрипта Предобработки:**
    - Объединить шаги (чтение файлов модуля, замена img->mermaid, сплиттинг) в единый скрипт Node.js (`npm run preprocess --module=<id>`).
    - Добавить логирование этапов.
    - Определить формат выходных данных (массив объектов-чанков).

**Результат Фазы 2:**
- Инструкция по конвертации DOCX в `README.md`.
- Рабочий модуль замены изображений на Mermaid (через LLM).
- Рабочий модуль разделения MD по заголовкам.
- Единый скрипт предобработки для указанного модуля.
- Проверенные предположения 1, 2, 5.

### **Фаза 3: Основной Конвейер - LLM и Supabase (Оценка: 5-7 дней)**

**Цель:** Реализовать обработку чанков с помощью LLM для извлечения информации и сохранение результатов в Supabase.

1. **Интеграция с LLM для Извлечения Информации:**
    
    - Реализовать вызов OpenRouter API для каждого чанка:
        
        - Передать текст чанка как контекст.
            
        - Использовать промпт (из конфигурации) для извлечения структурированной информации (например, генерации вопросов).
            
        - Определить и валидировать ожидаемый формат ответа (JSON).
            
    - Обработать ответы и ошибки API.
        
    - **Проверка Предположения 3 (LLM для Вопросов):** Протестировать на разных чанках, оценить качество вопросов/данных, итеративно улучшить промпт.
        
    - **Проверка Предположения 7 (API Limits - OpenRouter):** Мониторить лимиты во время тестов.
        
2. **Реализация Сохранения в Supabase:**
    
    - Определить и создать SQL-миграции для таблиц `source_documents`, `text_chunks`, `questions` (согласно схеме в PRD). Применить миграции к БД (локально/Coolify).
        
    - Реализовать функции для записи данных в Supabase с использованием `@supabase/supabase-js`:
        
        - Запись/обновление `source_documents` (с `module_id`).
            
        - Запись `text_chunks` (с `module_id`, `source_document_id`, метаданными LLM).
            
        - Запись `questions` (с `module_id`, `chunk_id`).
            
    - Реализовать логику проверки на существование или UPSERT для идемпотентности (по возможности).
        
3. **Создание Скрипта Основного Конвейера (Часть 1):**
    
    - Создать скрипт (`npm run pipeline --module=<id>`), который:
        
        - Принимает на вход чанки от этапа предобработки (или читает их из промежуточного хранилища/переменной).
            
        - Вызывает LLM для каждого чанка.
            
        - Сохраняет результаты (документ, чанки, вопросы) в Supabase.
            
    - Добавить логирование.
        

**Результат Фазы 3:**

- Рабочая интеграция с LLM для извлечения структурированной информации из чанков.
    
- Реализована схема БД в Supabase.
    
- Рабочие функции для сохранения данных в Supabase.
    
- Часть основного конвейера, обрабатывающая чанки и сохраняющая их в Supabase.
    
- Проверенное предположение 3.
    

### **Фаза 4: Векторизация и Qdrant (Оценка: 4-6 дней)**

**Цель:** Реализовать векторизацию данных из Supabase и их загрузку в Qdrant.

4. **Интеграция с vsegpt.ru API:**
    
    - Реализовать вызов API `vsegpt.ru` для векторизации текста (чанков или вопросов):
        
        - Настроить аутентификацию (API ключ из `.env`).
            
        - Указать модель `emb-openai/text-embedding-3-large`.
            
        - Обработать ответы и ошибки API.
            
    - **Проверка Предположения 4 (API vsegpt.ru):** Протестировать на разных текстах, проверить формат векторов, скорость, стабильность.
        
    - **Проверка Предположения 7 (API Limits - vsegpt.ru):** Мониторить лимиты во время тестов.
        
5. **Интеграция с Qdrant:**
    
    - Реализовать логику взаимодействия с Qdrant:
        
        - Проверка существования единой коллекции (имя из `.env`). **Не создавать** коллекции динамически.
            
        - Подготовка точек (вектор + payload).
            
        - Payload **обязательно** должен содержать `module_id` и ID из Supabase (`chunk_id`/`question_id`).
            
        - Загрузка/обновление точек в Qdrant (batch upsert).
            
    - Обработка ошибок Qdrant.
        
    - **Проверка Предположения 4 (Совместимость с Qdrant):** Загрузить тестовые векторы от vsegpt.ru, выполнить поиск по сходству.
        
6. **Доработка Скрипта Основного Конвейера (Часть 2):**
    
    - Добавить в скрипт `npm run pipeline --module=<id>`:
        
        - Чтение необходимых данных (чанков/вопросов) из Supabase для указанного `module_id`.
            
        - Вызов API vsegpt.ru для векторизации.
            
        - Загрузку векторов и payload в Qdrant.
            
    - Обеспечить последовательное или параллельное (с осторожностью) выполнение шагов конвейера.
        
    - Добавить логирование этапа векторизации.
        

**Результат Фазы 4:**

- Рабочая интеграция с API vsegpt.ru для векторизации.
    
- Рабочая интеграция с Qdrant для загрузки векторов с `module_id`.
    
- Завершенный основной конвейер (`pipeline`), выполняющий шаги от чтения чанков до загрузки векторов.
    
- Проверенные предположения 4 и 7.
    

### **Фаза 5: Развертывание, Документация и Тестирование (Оценка: 5-7 дней)**

**Цель:** Подготовить приложение к развертыванию, написать документацию, провести комплексное тестирование и подготовить пакет для передачи клиенту.

7. **Доработка Dockerfile и Конфигурации:**
    
    - Оптимизировать `Dockerfile` для production (multi-stage build, если нужно).
        
    - Убедиться, что все конфигурационные параметры вынесены в `.env`.
        
    - Подготовить `.env.example` со всеми необходимыми переменными и комментариями.
        
8. **Настройка Развертывания на Coolify:**
    
    - Создать/обновить конфигурацию сервисов в Coolify:
        
        - Приложение Node.js (сборка из Git + Dockerfile).
            
        - База данных PostgreSQL/Supabase.
            
        - Векторная база данных Qdrant.
            
    - Настроить переменные окружения и секреты в Coolify.
        
    - Настроить сетевое взаимодействие между сервисами в Coolify.
        
    - Протестировать запуск конвейера (`preprocess`, `pipeline`) на Coolify.
        
9. **Тестирование:**
    
    - **Модульное тестирование:** Покрыть основные функции (парсеры, клиенты API, обработчики данных) юнит-тестами (например, с использованием `jest`).
        
    - **Интеграционное тестирование:** Проверить взаимодействие между модулями (например, предобработка -> основной конвейер -> Supabase -> Qdrant).
        
    - **End-to-End Тестирование:** Запустить полный цикл для нескольких тестовых модулей (с разными `.docx`/`.md` файлами) и проверить корректность данных во всех хранилищах (Supabase, Qdrant). Проверить фильтрацию по `module_id` в Qdrant.
        
10. **Написание Документации (`README.md`):**
    
    - Детально описать проект: назначение, архитектура.
        
    - Включить "Руководство по Настройке Среды Разработки".
        
    - Добавить инструкцию по конвертации DOCX (`pandoc`).
        
    - Описать структуру входных данных в Git.
        
    - Объяснить все переменные окружения в `.env.example`.
        
    - Предоставить пошаговые инструкции по развертыванию всего стека на Coolify.
        
    - Описать команды для запуска конвейера (`npm run preprocess`, `npm run pipeline`).
        
    - Описать структуру базы данных Supabase и payload в Qdrant.
        
    - Добавить раздел по устранению неполадок (Troubleshooting).
        

**Результат Фазы 5:**

- Готовый к развертыванию Docker-образ приложения.
    
- Настроенные конфигурации для развертывания на Coolify.
    
- Проведены модульные, интеграционные и E2E тесты.
    
- Исчерпывающая документация `README.md`.
    
- Файл `.env.example`.
    

### **Фаза 6: Передача Проекта Клиенту (Оценка: 1-2 дня)**

**Цель:** Передать все артефакты проекта клиенту и обеспечить понимание процесса использования и развертывания.

11. **Подготовка Пакета Передачи:**
    
    - Убедиться, что Git-репозиторий содержит:
        
        - Весь исходный код Node.js.
            
        - `Dockerfile`.
            
        - `package.json`, `package-lock.json`.
            
        - `.gitignore`.
            
        - `.env.example`.
            
        - Полный `README.md`.
            
        - (Опционально) SQL-миграции.
            
        - (Опционально) `docker-compose.yml` для локального запуска.
            
12. **Передача Доступа:**
    
    - Предоставить клиенту доступ к Git-репозиторию проекта.
        
13. **Демонстрация и Обучение (Опционально):**
    
    - Провести демонстрацию работы системы.
        
    - Объяснить процесс настройки, развертывания на Coolify и запуска конвейера, следуя `README.md`.
        
    - Ответить на вопросы клиента.
        
14. **Фиксация Завершения:**
    
    - Получить подтверждение от клиента о приеме проекта.
        

**Результат Фазы 6:**

- Клиент получил доступ к репозиторию со всеми необходимыми артефактами.
    
- Клиент ознакомлен с документацией и процессом работы системы.
    

**Общая Оценка Трудозатрат:** ~23-34 рабочих дня (без учета времени на ожидание доступов, согласования, непредвиденные сложности). Рекомендуется добавить буфер (~15-25%).
